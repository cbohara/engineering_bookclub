################################
Chapter 1 - Pragmatic Philosophy
################################

###################################
what makes a pragmatic programmer?
###################################
1. early adopter/fast adapter
you have an instinct for technology + techniques
you love to try things out
when you learn something new, you grasp it quickly + integrate with existing knowledge 

2. inquisitive
you tend to ask questions
you are a pack rat for little facts 

3. critical thinker
you rarely take things as a given without examining the facts yourself

4. realistic
you try to understand the underlying nature of each challenge you face
have realistic expectations of how difficult the task is and how long it will take
gives you the stamina to keep at it

5. jack of all trades 
you try hard to be familiar with a broad range of technologies and environments
you work to keep aware of new developments 

care about your craft 

there is no point about developing software unless you care about doing it well

think about your work

ongoing critical appraisal
never run on autopilot

#########################
topic 1 - it's your life
#########################

take agency

does your work environment suck?
try to fix it, but not forever

want to work remotely? have you asked?
if they say no then find someone who will say yes

be proactive

#########################
topic 2 - the cat ate my source code
#########################
take responsibility for yourself + your actions in terms of career advancement and learning

your team needs to be able to trust you + rely on you 

responsibility is something you have to actively agree to
you have the right not to take responsibility

when you do take responsibility you need to be accountable for it
if you make mistakes admit it honestly and try to offer options

don't blame or make up excuses 

provide options, don't make lame excuses

before you approach anyone to tell them why something cannot be done, is late, is broken > stop + write it down
does your excuse sound reasonable or stupid?
how would it sound to your boss?
before you go and give them the bad news, is there anything else you can try?

instead of excuses, provide options
explain what can be done to salvage the situation

do you need to learn something at greater depth? 
would a book or course help?
don't be afraid to ask or admit that you need help

try to flush out the lame excuses before communicating them to someone else

"I don't know - but I will find out"
it's ok to admit you don't know AND take responsibility for learning more

#########################
topic 3 - software entropy
#########################

don't live with broken windows

don't leave "broken windows" (bad design, wrong decisions, poor code) unrepaired
fix it if you have time
if you do not have time, at least board it up
take some action to prevent further damage + show you are on top of the situation
neglect accelerates rot more than any other factor

don't cause collateral damage just because there is a crisis of some sort

#########################
topic 4 - stone soup + boiled frogs
#########################
good idea to create a MVP to share 
ppl tend to join an ongoing success vs a theoretical idea


be a catalyst of change

remember the big picture 

#########################
topic 5 - good enough software
#########################
allow users to determine if you've built software that is good enough for their needs
know when to stop and move on

make quality a requirements issue

often tradeoffs are involved when specifying requirements
many users would prefer to use software with rough edges today vs wait a year for the polished version
especially given what they may need something totally different in a year from now
if you givce your users something to play with earlier > feedback > better product

#########################
topic 6 - your knowledge portfolio
#########################
"An investment in knowledge always pays the best interest" -Ben Franklin
learning new things = most important strategic asset

how do you learn how to learn?
how do you learn what to learn?

1. invest regularly
consistently study

2. diversify
the more different things you know, the more valuable you are
as a baseline know the ins-and-outs of the technology you need today 
but don't stop there
the more tech you know > better to adjust to constant change

3. manage risk
don't put all your technical eggs in one basket
invest in high-risk, high-reward learning AND low-risk, low-reward learning

4. buy low sell high
learning an emerging technology before it becomes popular can be as hard as finding an undervalued stock
but the payoff can be just as rewarding

5. review and rebalance

invest regularly in your knowledge portfolio

1. learn at least one new programming language every year
different languages solve the same problems in different ways
learning diff approaches > broaden thinking + avoid getting stuck in a rut

2. read a technical book each month
web articles are great but books > deep understanding

3. read non-technical books too
computers are used by people
don't forget the human side of the equation = entirely different skill set

4. take classes

5. participate in local user groups + meetups
don't just go + listen
actively participate
learn what other people are working on outside of your company

6. experiment with diff environments
ex: be willing to work with Pycharm :)

7. stay current
keep your finger on the pulse on tech outside your current project

it doesn't matter if you use what you learn
the process of learning > expand thinking > open to new possibilities + new ways of doing things

opportunities for learning
if you don't know the answer to the question, find out!
take it as a personal challenge to find the answer

if you can't find the answer yourself, find other people who do know the answer
talk to other people about the problem + build your network

critically analyze what you read and hear 

critical thinking 
think critically about what you learn
ensure your knowledge is accurate
not swayed by vendor or media hype

ask the 5 whys 
a favorite consulting trick = ask why at least 5 times
may get closer to the truth as a result

who does this benefit? follow the money

what's the context?
consider an article touting best practices... best for who?
what are the prereqs? what are the consequences?
both short and long term

when or where would this work?
under what circumstances? 
don't stop at what will happen next, keep going to what will happen after that?

why is this a problem?
is there an underlying model?
does the underlying model work?

#########################
topic 7 - communicate 
#########################
a good idea is useless without effective communication
treat english like you would write code = DRY, ETC, automation

English is just another programming language 

know your audience

gather feedback 
don't just wait for questions - ask for questions
continually improve the knowledge of your audience as you communicate

know what you want to say
jot down a couple of ideas you want to communicate 
plan a couple strategies for getting them across

choose your moment
"is this a good time to talk about...?"

make it look good
check spelling

involve your audience
we often find that the documents we produce end up being less important than the process we go through to produce them
if possible, involve your readers in early drafts of the document
get their feedback + pick their brains
you'll build a good working relationship + you'll write a better doc as a result

be a listener
if you don't listen to them, they won't listen to you
encourage people to talk by asking questions
or have them summarize what you tell them
turn the meeting into a dialogue + you'll make your point more effectively
and who knows maybe you'll learn something :) 

get back to people
always respond to people even if it is to say "I'll get back to you later"
keeping people informed makes them far more forgiving of the occassional slip
makes them feel like you haven't forgotten them

it's both what you say and the way you say it 

the more effective your communication, the more influential you become
be mindful - email + slack is documentation that lasts forever 

write documentation
its an integral part of the development process
it can make it easier by not duplicating efforts or wasting time
keep the documentation close to the code 

build documentation in, don't bolt it on

it's easy to produce good looking documentation from the comments in source code
code shows how it is done
use the comments to share why something is done

################################
Chapter 2 - Pragmatic Approach
################################

#########################
topic 8 - the essence of good design 
#########################
good design is easier to change than bad design 

a thing is well designed if it adapts to the people who use it
for code, that means it must adapt by changing
ETC principle = easier to change

why is decoupling good? 
because by isolating concerns we make each easier to change

why is the single responsibility principle good?
because a change of requirements is mirrored by a change in just one module

why is naming important?
because good code names makes code easier to read
easier to read = easier to change

ETC is a value, not a rule
ask yourself consistently "did I just make the overall system easier or harder to change?"

try to make what you write replaceable
that way whatever happens in the future, this chunk of code won't be a roadblock
it's all about keeping code decoupled and cohesive 

not sure how things will change?
make a note of the choices you have
make a note of guesses of how things will change
later look back and review

challenge
think about languages and programming paradigms (OOP, functional)
do any have real big positives or negatives when it comes to writing ETC code?
Python = readable = easy to understand = easy to change

what about functional programming?

#########################
topic 9 - DRY 
#########################
do not duplicate knowledge throughout your systems

requirements are always changing
we spend most of our time in maintaince mode, reorganizing and re-expressing the knowledge in our system

the alternative is having the same thing expressed in 2+ places

rather than writing code that represents external data in a fixed structure, just stick it into a key/value data structure
avoids breaking changes
later validate the map contains the data you need in order to proceed 

#########################
topic 10 - orthogonality 
#########################
orthogonality in computing = decoupling 
2+ things are orthogonal if changes in 1 system do not affect any others

when components of a system are highly independent, there is no such thing as a local fix

we want to design components that are
- self-contained
- independent
- with a single, well-defined purpose

increase productivity
changes localized > development time + testing time reduced

promotes reuse
if components have specific, well-defined responsibilities, they can be combined with new components
regardless if originally envisioned those components interacting

reduce risk
easier to slice out broken components + replace 
make small changes to one area > should only affect that small area = not cascading failures
better tested = easier to run tests on small components
you will not be as tightly coupled to a third party vendor bc interfaces are isolated to small components 
can swap out later on if things change

design
once you have components mapped out ask yourself
"if I dramatically change the requirements behind a particular function, how many modules are affected?"
the answer should be 1 

how decoupled are you from changes made in the real world?
are you using a telephone # as user ID?
what if telephone company changes area codes?
don't rely on properties of things you cannot control

coding
keep your code decoupled
write shy code
- modules that do not reveal anything unnecessary to other modules
- modules that do not rely on other module's implementations
if you need to change an object's state, get the object to do it for you

avoid global data
every time your code references global data it ties itself into other components that share that data
solution = explicitly pass any required context into your modules

testing
writing good unit tests > modular code 
when bug fixing ask yourself how localized the fix is
when you make a fix, do other problems arise?
tag bug fixes when you check in code after testing
you can then run monthly reports analyzing trends in the number of source files affected by each bug fix

#########################
topic 11 - reversibility 
#########################
as the pace of change increases, it becomes harder and harder to keep our applications relevant 
techniques to help insulate projects from their changing environments

engineers prefer simple, singular solutions to problems
however everything always changes

the goal is to produce flexible, adaptable software
requirements, users, and hardware change faster than we can get the software developed

ex: supposed you decide to use relational database from vendor A
after performance testing you realize the document database from vendor B is faster
if you really abstracted the idea of the database out - to the point where it simply provides persistence as a service - then you have the flexibility to change horses midstream

the mistake lies in assuming that any decision is permenant

there are no final decisions
flexible architecture
not only made code flexible
also think about maintaining flexibility in the areas of architecture, deployment, and vendor integrations

how many possible futures can your code support?

what you can do to make it easy to change
hide third-party APIs behind your own abstraction layers
break code into components

forgo following fads

#########################
topic 12 - tracer bullets 
#########################
style of development that allows you to gather requirements, test design, and implement code at the same time
it's the only way to keep up with the pace of modern life

shooters have tracer bullets to visualize where their bullets have landed
there is a need for immediate feedback under actual conditions with a moving goal
especially when building something that hasn't been built before
you are trying to hit a target in the dark

because your users haven't usea  system like this before, their requirements will be vague
because you may be using unfmiliar algos, tools, techniques, library = lots of unknowns
because these projects take tiem to complete, guarantee the environment will change before you're done

code that glows in the dark
tracer bullets work bc they operate in the same env and under same constraints as real bullets
they get to the target fast > immediate feedback
relatively cheap

looking for something that gets us from a requirement > some aspect of the final system quickly, visibly, and repeatably

look at important requirements (the ones that define the system)
look at areas when you have doubts 
look at areas wheere you see the biggest risks
then prioritize your development so these are the first areas you code

tracer code is not disposible
it contains all the error checking, structuring, docs, self-checking as prod code
it simply is not fully functional
once you have achieved an end-to-end connection amongst the components of your system, you can check how close to the target you are
adjust as necessary
once you are on target, adding functionality is easy

incremental approach

advantages
1. user gets to see something working early
users get to contribute as the project progresses = increase their buy-in
they will let you know how close to the target you are

business users have a vague idea of what they want to achieve
but they neither know nor care about the details
that's part of our value as software engineers - we intuit intent and convert it to code
it's better to provide working code + get feedback ASAP

2. developers build a structure to work in
the most daunting piece of paper is the one with nothing written on it
get the most basic end-to-end path built ASAP

3. you have an integration platform
easy to integrate new pieces of code that have been unit tested

4. you have something to demonstrate

5. you have a better feel for progress
tackle use cases 1-by-1
when one is done, move on to the next
far easier to measure performance + demonstrate progress to your user
avoid creating monolithic blocks of code that are reported as 95% complete week after week

tracer bullets don't always hit their target
don't be surprised if your first couple of attempts miss
user says "that's not what I meant" 
or data you need isn't avaialble when you need it 
or performance problems seem likely

#########################
topic 13 - prototypes and post it notes 
#########################
use prototyping to test architectures, algorithms, interfaces, and ideas
it is critical to test ideas and get feedback before you commit to them

prototyping is different
you are aiming to explore specific aspects of the final system
you throw away whatever you put together 
use lessons learned to recode it properly

prototypes + post-it notes
post it notes are great for prototyping workflows + app logic
UI = drawing on whiteboard

what details can you ignore?
correctness = use dummy data
completeness = preselected single functionality
robustness = no need to test
style = no docs or comments

prototypes are constructed to model the entire system under consideration
none of the individual modules need to be particularly functional

specific areas you may want to look for in architectural prototype
1. are the responsibilities of the major components well defined + appropriate?
2. are the collaborations between the major components well defined?
3. is coupling minimized?
4. can you ID potential sources of duplication?
5. are interface definitions + constraints acceptable?
6. does every module have an access path to the data it needs during execution?  do it have access when it needs it? 
this last question tends to generate the most surprises + most valuable results from prototyping

how not to prototype
before you start, make sure ppl know you are writing disposable code
if you worry ppl will mistake the purpose of prototyping, go with tracer bullet approach instead

#########################
topic 14 - domain languages 
#########################
computer languages influence how you think about a problem
how you think about communicating 

#########################
topic 15 - estimating 
#########################
world of limited time + resources
keep boss + clients happier if you get good at working out how long things will take

****** find out ********
how long would it take to send 75TB over a 1Gbps network?
how much storage would you need for a million names + addresses?
how long does it take to compress 100Mb of text?

they can be answered as long as you are comfortable with estimating
in the process of producing the estimate, you'll come to understand more about the world your programs inhabit

estimate to avoid surprises

a basic estimating trick - ask someone who's already done it
see how others have solved a similar problem
draw on other people's experiences
give you a better sense of how long things will take

understand what's being asked
you need to grasp the scope of the domain

project scope
part of the project planning that involves determining + documenting 
specific project goals, deliverables, features, functions, tasks, deadlines, + costs

domain = application domain = sphere of knowledge

need to get in the habit of thinking about the scope of the project before starting to guess

build a model of the system
from your understanding of the question being asked
build a rough-and-ready bare-bones mental model
can be creative + useful in the long-term
ex: you asked for an estimate to do X. however, Y a variant of X could be done in half the time, and you lose only 1 feature

break the model into components
identify parameters
give each parameter a value

calculate the answers
only in the simplest of cases will an estimate have a single answer
run multiple calculations, varying the values of the critical parameters, until you work out which ones really drive the model
ex: the response time is roughly 3/4 second if the system have SSDs and 32GB of memory, and 1 sec with 16GB memory

keep track of your estimating prowess
****keep a record of your estimates****
later evaluate how close you were
if your estimate is wrong, find out why it differed from your guess

estimating project schedules
unless you are doing an app similar to a previous one, with the same team and same tech, you are just guessing

so what do you do?
practice incremental development
complete the coding + testing of initial functionality = first iteration

for each iteration
- check requirements
- analyze risk
- design, implement, integrate
- validate with the users

based on that experience > refine your initial guess on the # of iterations + what is included in each

iterate the schedule with the code
this is not popular with management who typically want a single, hard-and-fast number before a project even starts
you'll have to help them understand that the team, their productivity, and the environment will determine the schedule
redefining the schedule after each iteration > more accurate estimates

what to say when asked for an estimate
"I'll get back to you"
you almost always get better results if you slow the process down + spend some time to plan
estimates given without thought will come back to haunt you

################################
Chapter 3 - The Basic Tools 
################################
always be on the lookout for better ways of doing things

#########################
topic 16 - the power of plain text 
#########################
our base material is knowledge
best wayto store knowledge persistently = plain test

plain text doesn't have to be unstructured

human-readable forms of data + self-describing data will outlive all other forms of data + the apps that created them

Unix philosophy
small, sharp tools
each indended to do 1 thing well
enabled by using a common underlying format = line-oriented plain text file

challenge
design a small address book database using straightforward binary representation in Python
translate that format into plain text format using XML

#########################
topic 17 - shell games
#########################
use the power of command shells

#########################
topic 18 - power editing 
#########################
stick with vim :) 

#########################
topic 19 - version control 
#########################
always use version control

#########################
topic 20 - debugging 
#########################
use binary "chop" aka binary search when trying to find the data that is causing your program to fail

do you know this bug could arise elsewhere?  fix it right away

what could you do to find the bug?  better log parsing system?

debugging checklist
is the program being reported a direct result of the underlying bug, or just a symptom?
assume the bug is in your code - not the OS or framework
rubber duck it

#########################
topic 21 - text manipulation 
#########################
take advantage of Python scripts to automate all the things

#########################
topic 22 - engineering daybooks
#########################
take notes about your day
jot down ideas and reflections so you don't forget

################################
Chapter 4 - Pragmatic Paranoia
################################
just like defensive driving, practice defensive coding
if there is any doubt, validate all info given
use assertions to detect bad data
distrust data from potential attackers
check for consistency, put constraints on DB

you can't write perfect software
buld in defenses against your own mistakes

#########################
topic 23 - design by contract
#########################
clients + suppliers must agree on rights + responsibilities in a contract

what is a correct program?
one that does no more and no less than it claims to do
documenting + verifying that claim = design by contract

every function + method in a software system does something
before it does something, the function may have expectations of the state of the world
and it may be able to make a statement about the state of the world when it concludes 

preconditions
what must be true in order for the routine to be called
a routine should never get called when its preconditions would be violated
it is the caller's responsibility to pass good data
ex: sqrt function has a precondition - its argument must not be negative
if a user enters a negative number, it's up to the calling code to ensure it doesn't pass the negative number to the sqrt function
calling code should terminate, or issue a warning and retry
whatever it's choice, it is definitely not the sqrt's problem
need to handle the exception in the calling function
by expressing the domain of the sqrt function in the precondition of the sqrt function, you shift the burden of correctness to the caller

postconditions
what the routine is quaranteed to do
the state of the world when the routine is done

class invariants
invariant = never vary
logical assertion that is always held true during a certain phase of execution
use assertions to make invariants explicit
some OOP have special syntax for specifying class invariants = constrain objects of a class
methods of the class should preserve the invariant
class invariant constrains the state stored in the object

the contract 
if all the routine's preconditions are met by the caller,
the routine shall guarantee that all postconditions are true when it completes
the routine shall guarantee that all class invariants are true when it completes

if either party fails to live up to the terms of the contract, then an agreed upon remedy is invoked
raise an exception, program terminates

failure to live up to the contract is a bug
it is not something that should ever happen

DBC and TDD
Both serve their usecases but are not mututually exclusive
TDD is great but it might invite you to concentrate on the happy path, not real world full of bad data

Advantages of DBC
- doesn't require any setup or mocking
- defines the parameters for success or failure in ALL cases (vs tests for specific cases)
- TDD only happens at test time in build cycle vs DBC required for code to execute
- TDD does not focus on checking internal invariants 
- DBC is more efficient + DRYer

emphasis is on lazy code
be strict in what you accept before you begin
promise as little as possible in return

implementing DBC
- what the input domain range is
- what the boundary conditions are
- what the routine promises to deliver
- what the route does not promise to deliver

documenting these details before you write code > huge leap forward in writing better software
add to commments or in unit tests

in some languages DBC is built in 
when it is not, you can use assertions
by using assert to validate preconditions, postconditions, + invariants > crash early @ site of problem

#########################
topic 24 - dead programs tell no lie 
#########################
do no damage while working bugs out
check things often + terminate the program if things go awry

coding defensively
making sure the data is what we think it is
making sure the code in prod is the code we think it is
making sure the correct versions of dependencies were actually loaded

all errors give you info
read the damn error message

some developers think it is good style to catch or rescue all exceptions
re-raising them after writing some kind of log message
this is not advised 

why?
the app code isn't eclipsed by the error handling

the code is less coupled
what if the function defining the exception is updated?
then the code executing the function and trying to handle all the exceptions is out of date

preferred to allow the exception to be automatically propogated

crash early
crashing your program is the best thing you can do
when your code discovers something that was supposed to be impossible just happened, your program is no longer viable
anything it does from this point forward become suspect
terminate it as soon as possible

#########################
topic 25 - assertive programming 
#########################
write code that actively verifies your assumptions

anything you think "but of course that could never happen" add code to chec k it

assertions + side effects
be careful of adding assertions > new errors

never put code that must be executed into an assert

don't use assertions in place of real error handling
assertions check for things that should never happen

leave assertions turned on

#########################
topic 26 - how to balance resources 
#########################
as programs get more dynamic, you'll find yourself juggling system resources (memory, files, etc)

#########################
topic 27 - don't outrun the headlights
#########################
stick with small steps

